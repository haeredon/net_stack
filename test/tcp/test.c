#include "handlers/ipv4/ipv4.h"
#include "handlers/tcp/tcp.h"
#include "handlers/tcp/tcp_shared.h"
#include "handlers/tcp/tcp_tcb.h"
#include "handlers/tcp/tcp_block_buffer.h"
#include "handlers/ethernet/ethernet.h"
#include "test.h"
#include "test/common.h"

#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <stdlib.h>

/*************************************
 *          TEST DATA                *
**************************************/


/* Frame (74 bytes) */
static const unsigned char tcp_3_way_handshake_1[60] = {
    0x45, 0x00, 0x00, 0x3c, 0x27, 0xe8, 0x40, 0x00, 
    0x40, 0x06, 0x08, 0x7a, 0xc0, 0xa8, 0x00, 0x75, 
    0x20, 0x20, 0x20, 0x20, 0xde, 0xc2, 0x01, 0xbb,
    0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 
    0xa0, 0x02, 0xfa, 0xf0, 0x11, 0x11, 0x00, 0x00, 
    0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 
    0x22, 0xe6, 0x59, 0xfa, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x03, 0x03, 0x07                                      
};

/* Frame (74 bytes) */
static const unsigned char tcp_3_way_handshake_2[60] = {
    0x01, 0xbb, 0xde, 0xc2, 0x00, 0x00, 0xaa, 0x00, 
    0x00, 0x00, 0x00, 0x0c, 0x50, 0x12, (((uint16_t) TCP_RECEIVE_WINDOW) & 0xFF00) >> 8, (((uint16_t) TCP_RECEIVE_WINDOW) & 0x00FF), 
    0x11, 0x11, 0x00, 0x00, 0x02, 0x04, 0x05, 0x84, 
    0x04, 0x02, 0x08, 0x0a, 0x88, 0x41, 0x03, 0x0f, 
    0x22, 0xe6, 0x59, 0xfa, 0x01, 0x03, 0x03, 0x08                                      
};
static const uint8_t tcp_3_way_handshake_2_size = 20; /* we are not testing options */


/* Frame (66 bytes) */
static const unsigned char tcp_3_way_handshake_3[60] = {
    0x45, 0x00, 0x00, 0x34, 0x27, 0xe9, 0x40, 0x00, 
    0x40, 0x06, 0x08, 0x81, 0xc0, 0xa8, 0x00, 0x75,
    0x20, 0x20, 0x20, 0x20, 0xde, 0xc2, 0x01, 0xbb, 
    0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0xaa, 0x01, 
    0x80, 0x10, 0x01, 0xf6, 0x11, 0x11, 0x00, 0x00, 
    0x01, 0x01, 0x08, 0x0a, 0x22, 0xe6, 0x5a, 0x26, 
    0x88, 0x41, 0x03, 0x0f                                      
};

/* Frame (583 bytes) */
static const unsigned char tcp_3_way_handshake_4[569] = {
    0x45, 0x00,                                     /* .R}g..E. */
    0x02, 0x39, 0x27, 0xea, 0x40, 0x00, 0x40, 0x06, /* .9'.@.@. */
    0x06, 0x7b, 0xc0, 0xa8, 0x00, 0x75, 0x8e, 0xfa, /* .{...u.. */
    0xba, 0x42, 0xde, 0xc2, 0x01, 0xbb, 0x02, 0x2c, /* .B....., */
    0xe3, 0xa4, 0x82, 0x7e, 0x4a, 0xf8, 0x80, 0x18, /* ...~J... */
    0x01, 0xf6, 0x0c, 0x86, 0x00, 0x00, 0x01, 0x01, /* ........ */
    0x08, 0x0a, 0x22, 0xe6, 0x5a, 0x2e, 0x88, 0x41, /* ..".Z..A */
    0x03, 0x0f, 0x16, 0x03, 0x01, 0x02, 0x00, 0x01, /* ........ */
    0x00, 0x01, 0xfc, 0x03, 0x03, 0xbd, 0x4c, 0xc9, /* ......L. */
    0x79, 0x55, 0xe5, 0xea, 0x3a, 0xa1, 0xce, 0xbb, /* yU..:... */
    0x18, 0x9f, 0x50, 0xe1, 0xed, 0xb0, 0x61, 0x77, /* ..P...aw */
    0xc4, 0xa0, 0x49, 0x70, 0xc4, 0x62, 0xa3, 0x8c, /* ..Ip.b.. */
    0xc1, 0xda, 0x9e, 0x64, 0xa6, 0x20, 0x17, 0x63, /* ...d. .c */
    0x2c, 0xa5, 0xfa, 0xdf, 0xc9, 0x03, 0xa4, 0x72, /* ,......r */
    0x2d, 0x45, 0xe4, 0x34, 0x15, 0x02, 0xb2, 0x13, /* -E.4.... */
    0x8a, 0x4e, 0xee, 0x37, 0xa7, 0x6b, 0xcd, 0x70, /* .N.7.k.p */
    0xfc, 0xbd, 0x97, 0x35, 0x99, 0x3f, 0x00, 0x22, /* ...5.?." */
    0x13, 0x01, 0x13, 0x03, 0x13, 0x02, 0xc0, 0x2b, /* .......+ */
    0xc0, 0x2f, 0xcc, 0xa9, 0xcc, 0xa8, 0xc0, 0x2c, /* ./....., */
    0xc0, 0x30, 0xc0, 0x0a, 0xc0, 0x09, 0xc0, 0x13, /* .0...... */
    0xc0, 0x14, 0x00, 0x9c, 0x00, 0x9d, 0x00, 0x2f, /* ......./ */
    0x00, 0x35, 0x01, 0x00, 0x01, 0x91, 0x00, 0x00, /* .5...... */
    0x00, 0x22, 0x00, 0x20, 0x00, 0x00, 0x1d, 0x70, /* .". ...p */
    0x61, 0x67, 0x65, 0x61, 0x64, 0x32, 0x2e, 0x67, /* agead2.g */
    0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x79, 0x6e, /* ooglesyn */
    0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, /* dication */
    0x2e, 0x63, 0x6f, 0x6d, 0x00, 0x17, 0x00, 0x00, /* .com.... */
    0xff, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0a, 0x00, /* ........ */
    0x0e, 0x00, 0x0c, 0x00, 0x1d, 0x00, 0x17, 0x00, /* ........ */
    0x18, 0x00, 0x19, 0x01, 0x00, 0x01, 0x01, 0x00, /* ........ */
    0x0b, 0x00, 0x02, 0x01, 0x00, 0x00, 0x23, 0x00, /* ......#. */
    0x00, 0x00, 0x10, 0x00, 0x0e, 0x00, 0x0c, 0x02, /* ........ */
    0x68, 0x32, 0x08, 0x68, 0x74, 0x74, 0x70, 0x2f, /* h2.http/ */
    0x31, 0x2e, 0x31, 0x00, 0x05, 0x00, 0x05, 0x01, /* 1.1..... */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x0a, /* .....".. */
    0x00, 0x08, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03, /* ........ */
    0x02, 0x03, 0x00, 0x33, 0x00, 0x6b, 0x00, 0x69, /* ...3.k.i */
    0x00, 0x1d, 0x00, 0x20, 0x05, 0xc1, 0x27, 0x75, /* ... ..'u */
    0x8c, 0x90, 0x81, 0xf4, 0x29, 0xd3, 0x11, 0x82, /* ....)... */
    0xf8, 0xcb, 0x28, 0xad, 0x91, 0xb5, 0x8e, 0xac, /* ..(..... */
    0x78, 0xba, 0xa2, 0xe5, 0xba, 0xb5, 0xe6, 0x5a, /* x......Z */
    0x05, 0x9b, 0xfa, 0x57, 0x00, 0x17, 0x00, 0x41, /* ...W...A */
    0x04, 0xf3, 0x57, 0xee, 0x0b, 0x0c, 0xff, 0x9a, /* ..W..... */
    0x23, 0x92, 0x4d, 0x9a, 0x0c, 0xf3, 0x6d, 0x26, /* #.M...m& */
    0x23, 0xb1, 0x2f, 0x6f, 0xde, 0x0d, 0x32, 0x79, /* #./o..2y */
    0x7f, 0xc5, 0x70, 0xda, 0x17, 0x42, 0xbb, 0xf6, /* ..p..B.. */
    0xf8, 0x9b, 0xbc, 0x67, 0xab, 0xb8, 0x88, 0x60, /* ...g...` */
    0xd8, 0x14, 0x98, 0x92, 0x9f, 0xfe, 0x5c, 0x7a, /* ......\z */
    0x29, 0x04, 0x54, 0xa7, 0x1b, 0x4e, 0x73, 0xa1, /* ).T..Ns. */
    0xc4, 0x41, 0x32, 0xa1, 0x0d, 0x3b, 0x37, 0xd8, /* .A2..;7. */
    0xc2, 0x00, 0x2b, 0x00, 0x05, 0x04, 0x03, 0x04, /* ..+..... */
    0x03, 0x03, 0x00, 0x0d, 0x00, 0x18, 0x00, 0x16, /* ........ */
    0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x08, 0x04, /* ........ */
    0x08, 0x05, 0x08, 0x06, 0x04, 0x01, 0x05, 0x01, /* ........ */
    0x06, 0x01, 0x02, 0x03, 0x02, 0x01, 0x00, 0x2d, /* .......- */
    0x00, 0x02, 0x01, 0x01, 0x00, 0x1c, 0x00, 0x02, /* ........ */
    0x40, 0x01, 0x00, 0x15, 0x00, 0x79, 0x00, 0x00, /* @....y.. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00        /* ....... */
};

/* Frame (66 bytes) */
static const unsigned char tcp_3_way_handshake_5[32] = {
    0x01, 0xbb, 0xde, 0xc2, 0x82, 0x7e, /* .u.....~ */
    0x4a, 0xf8, 0x02, 0x2c, 0xe5, 0xa9, 0x80, 0x10, /* J..,.... */
    0x01, 0x0b, 0xcc, 0xfc, 0x00, 0x00, 0x01, 0x01, /* ........ */
    0x08, 0x0a, 0x88, 0x41, 0x03, 0x3b, 0x22, 0xe6, /* ...A.;". */
    0x5a, 0x2e                                      /* Z. */
};


/*************************************
 *          UTILITY                  *
**************************************/
struct tcp_cmp_ignores_t {
    bool sequence_num;
    bool checksum; 
};

struct tcp_cmp_ignores_t ignores = {
    .sequence_num = true,
    .checksum = true
};
struct response_t tcp_last_response;
uint8_t tcp_response_buffer[4096];

int64_t tcp_test_write(struct response_t response) {
    memcpy(&tcp_last_response, &response, sizeof(struct response_t));
    memcpy(&tcp_response_buffer, response.buffer, sizeof(tcp_response_buffer));
    tcp_last_response.buffer = tcp_response_buffer;
}


bool is_tcp_packet_equal3(struct tcp_header_t* a, struct tcp_header_t* b, struct tcp_cmp_ignores_t* ignores) {
    return a->source_port == b->source_port &&
    a->destination_port == b->destination_port &&
    (a->sequence_num == b->sequence_num || ignores->sequence_num) &&
    a->acknowledgement_num == b->acknowledgement_num &&
    a->data_offset == b->data_offset &&
    a->control_bits == b->control_bits &&
    a->window == b->window &&
    (a->checksum == b->checksum || ignores->checksum) &&
    a->urgent_pointer == b->urgent_pointer;
}

// bool is_tcp_packet_equal2(struct tcp_header_t* a, struct tcp_header_t* b) {
//     return is_tcp_packet_equal3(a, b, false);
// }

/*************************************
 *          TESTS                *
**************************************/
bool tcp_test_basic(struct handler_t* handler, struct test_config_t* config) {
    struct packet_stack_t first_stack = { 
    .pre_build_response = 0, .post_build_response = 0,
    .packet_pointers = tcp_3_way_handshake_1, .write_chain_length = 1 };

    first_stack.packet_pointers[1] = tcp_3_way_handshake_1 + 20;
    
    if(handler->operations.read(&first_stack, config->interface, handler)) {
        return false;
    }

    if(tcp_last_response.size != tcp_3_way_handshake_2_size ||
       !is_tcp_packet_equal3((struct tcp_header_t*) tcp_response_buffer, (struct tcp_header_t*) tcp_3_way_handshake_2, &ignores)) {
        return false;
    }

    struct packet_stack_t second_stack = { 
        .pre_build_response = 0, .post_build_response = 0,
        .packet_pointers = tcp_3_way_handshake_3, .write_chain_length = 1 
    };

    second_stack.packet_pointers[1] = tcp_3_way_handshake_3 + 20;

    if(handler->operations.read(&second_stack, config->interface, handler)) {
        return false;
    }

    // check that no response was send

    struct packet_stack_t third_stack = { 
        .pre_build_response = 0, .post_build_response = 0,
        .packet_pointers = tcp_3_way_handshake_4, .write_chain_length = 1 
    };

    third_stack.packet_pointers[1] = tcp_3_way_handshake_4 + 20;

    if(handler->operations.read(&third_stack, config->interface, handler)) {
        return false;
    }

    // check that the correct reponse was send and that it is equal to tcp_3_way_handshake_5

    return true;
}

/*************************************
 *          BOOTSTRAP                *
**************************************/
bool tcp_tests_start() {        
    struct handler_config_t handler_config = { 
        .mem_allocate = test_malloc, 
        .mem_free = free 
    };	

    struct interface_t interface = {
        .port = 0,
        .port = 0,
        .operations.write = tcp_test_write,
        .ipv4_addr = OWN_IP,
        .mac = 0
    };
    memcpy(&interface, OWN_MAC, ETHERNET_MAC_SIZE);

    struct test_config_t test_config = { 
        .interface = &interface
    };	

	struct handler_t* tcp_handler = tcp_create_handler(&handler_config); 
	tcp_handler->init(tcp_handler);

    struct tcp_socket_t* socket = (struct tcp_socket_t*) malloc(sizeof(struct tcp_socket_t));
    socket->listening_port = htons(443);
    socket->interface = &interface;
    tcp_add_socket(socket, tcp_handler);

    struct test_t* test = (struct test_t*) malloc(sizeof(struct test_t));
    strncpy(test->name, "3-Way Handshake", sizeof("3-Way Handshake"));    
    test->test = tcp_test_basic;

    /*
     * need test for 
     *      edge cases on receive window
     *      edge cases for ack vs seq
     *      teardown correctly on error
     *      reacts correctly to fin and rst
     *      checksum validation
     *      close connection if outbound buffer full
     *      out and in buffer fills up
    */

    struct test_t* tests[2];
    tests[0] = test;
    tests[1] = 0; // zero out last pointer to mark end of array

    struct test_run_t ipv4_test_run = {
        .config = &test_config,
        .handler = tcp_handler,
        .tests = tests       
    };

    run_tests(&ipv4_test_run);
}



